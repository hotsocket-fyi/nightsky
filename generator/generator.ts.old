import { Lexicon, Object as LObject, Params, PrimaryTypes, Procedure, Query, Record as LRecord } from "./lexicon.ts";

export function addImport(imports: Record<string, string[]>, from: string, name: string) {
	if (!imports[from]) imports[from] = [];
	imports[from].push(name);
}
export function convertRef(ref: string, data: any, imports: Record<string, string[]>): string {
	const endID = data.id.substring(data.id.lastIndexOf(".") + 1);
	const newRef = ref.replace("#", ".$");
	if (ref.startsWith("#")) {
		return `${endID}${newRef}`;
	} else {
		addImport(imports, "@/index.ts", "AT");
		return `AT.${newRef}`;
	}
}
export function convertType(prop: any, data: any, imports: Record<string, string[]>): string {
	switch (prop.type) {
		case "array":
			return `${convertType(prop.items, data, imports)}[]`;
		case "ref":
			return convertRef(prop.ref, data, imports);
		case "union":
			return (prop.refs as string[]).map((ref) => `\n\t\t| ${convertRef(ref, data, imports)}`).join("");
		case "integer":
			return "number";
		case "unknown":
			return "T";
		default:
			return prop.type;
	}
}
export function convertDef(
	_name: string,
	input: any,
	data: any,
	imports: Record<string, string[]>,
	depth: number = 0,
): string {
	const endID = data.id.substring(data.id.lastIndexOf(".") + 1);
	const defParts: string[] = [];
	let name = _name;
	if (name.endsWith("<T>")) {
		addImport(imports, "@/impl/types.ts", "SerializableObject");
		name = name.replace("T", "T extends SerializableObject");
	}
	defParts.push(`export interface ${name == "main" ? endID : (name.startsWith("_") ? name : `$${name}`)} {`);
	const obj = input.record ? input.record : input;
	const required = obj.required as string[];
	addImport(imports, "@/impl/types.ts", "Serializable");
	defParts.push(
		`\t[key: string]: ${name == "_parameters" ? "string | number | boolean | null | undefined" : "Serializable"};`,
	);
	for (const k in obj.properties) {
		const prop = obj.properties[k];
		const propComments: string[] = [];
		if (prop.description) {
			const desc: string = prop.description;
			const depr = desc.split(/^deprecated(?::|\.)/i);
			if (depr.length > 1) {
				depr[0] = "@deprecated";
			}
			propComments.push(depr.join(""));
		}
		//if (prop.maxLength) propComments.push(`@maxLength ${prop.maxLength}`);
		const optional = (required && required.indexOf(k) < 0) ? "?" : "";
		if (propComments.length > 0) {
			defParts.push(`\t/** ${propComments.join("\n\t * ")} */`.replaceAll("\n", "\n\t"));
		}

		defParts.push(`\t${k}${optional}: ${convertType(prop, data, imports)};`);
	}
	defParts.push("}");
	return defParts.map((part) => "\t".repeat(depth) + part).join("\n");
}
export function convertFile(input: string): string {
	try {
		const data: Lexicon = JSON.parse(input);
		const inID = data.id as string;
		const outputLines: string[] = [];
		const imports: Record<string, string[]> = {};
		const endID = inID.substring(inID.lastIndexOf(".") + 1);
		const defs: Record<string, PrimaryTypes | LObject | Params> = data.defs;

		// find out if there's a "main" def, and act accordingly.
		if ("main" in data.defs) {
			const def = data.defs.main;
			if (defs["main"].type == "query" || defs["main"].type == "procedure") {
				const rpcDef = def as Query | Procedure;
				// no description for doc comment, need to add this part still.
				outputLines.push(`/**${rpcDef.description ? " " + rpcDef.description : ""}`);
				let hasUnknown = false;
				const isQuery = rpcDef.type == "query";
				const schema = isQuery ? rpcDef.output?.schema : rpcDef.input?.schema;
				if (schema && schema.type === "object" && schema.properties) {
					const scanProps = schema.properties;
					for (const k in scanProps) {
						if (scanProps[k].type == "unknown") {
							hasUnknown = true;
							break;
						}
					}
				}
				const operationType = isQuery ? "query" : "procedure";
				addImport(imports, "@/impl/requests.ts", operationType);
				addImport(imports, "@/lib.ts", "XError");
				const TT = hasUnknown ? "<T>" : "";
				// push input/output to defs if it's an object
				let inputType = `${endID}.${isQuery ? "_parameters" : "_input" + TT}${isQuery ? "" : TT}`;
				let outputType = `${endID}._output${isQuery ? TT : ""}`;
				if (isQuery) {
				}

				if (TT != "") addImport(imports, "@/impl/types.ts", "SerializableObject");
				// the function
				const filled = ` * @${rpcDef.type}
 */
async function ${endID}${TT.replace("T", "T extends SerializableObject")}(
	service: URL,
	headers: Headers,
	input: ${inputType},
): Promise<${rpcDef.output ? outputType : "void"} | XError> {
	return await ${operationType}<${outputType}>({
		method: "${inID}",
		service: service,
		headers: headers,
		input: input,
	});
}`;
				outputLines.push(...(filled.split("\n")));
				delete data.defs["main"];
			}
		}
		if (data.defs["main"]) {
			outputLines.push(convertDef("main", data.defs["main"], data, imports));
			delete data.defs["main"];
		}
		if (Object.keys(data.defs).length > 0) {
			outputLines.push("// deno-lint-ignore no-namespace");
			outputLines.push(`export namespace ${endID} {`);
			for (const k in data.defs) {
				outputLines.push(convertDef(k, data.defs[k], data, imports, 1));
			}
			outputLines.push("}");
		}
		outputLines.push(`\nexport default { ${endID} };`);

		const importLines: string[] = [];
		for (const k in imports) {
			importLines.push(`import { ${new Set(imports[k]).values().toArray().join(",")} } from "${k}";`);
		}
		return "// Generated code. Edits will likely not be retained.\n\n" +
			importLines.join("\n") + "\n\n" +
			outputLines.join("\n");
	} catch (e) {
		console.log(input);
		throw e;
	}
}
